//
//  ChatModel.swift
//  Chatbot
//
//  Created by Umang Kedan on 21/03/24.
//

import FirebaseDatabaseInternal

struct Message: MessageType {
    var sender: SenderType
    var messageId: String
    var sentDate: Date
    var kind: MessageKind
}

struct Sender: SenderType {
    var senderId: String
    var displayName: String
}

public enum MessageKind {
    case text(String)
    
    var decode:String {
        switch self {
        case .text(let text):
            return text
        }
    }
}

public protocol MessageType {
  var sender: SenderType { get }
  var messageId: String { get }
  var sentDate: Date { get }
  var kind: MessageKind { get }
}

public protocol SenderType {
  var senderId: String { get }
  var displayName: String { get }
}

class ChatModel: NSObject {
    
    let messagesDatabase = Database.database().reference().child("conversation")
    
    /**
     func generateConversationID(user1ID: String, user2ID: String) -> String
     - Note: Used to generate a Unique String which will be used for generating unique chats between users.
     - parameter user1ID: User's (certainly sender)Unique UID generated after Successfull Authentication at firebase
     - parameter user2ID: User's (certainly other user)Unique UID generated after Successfull Authentication at firebase
     - returns: Sorted unique ID in String
     - warning: Do-not modify unless you have a better implementation
     */
    func generateConversationID(user1ID: String, user2ID: String) -> String {
        let sortedUserIDs = [user1ID, user2ID].sorted()
        let conversationID = sortedUserIDs.joined(separator: "_")
        return conversationID
    }
    
    /**
     func getOtherUserID(conversationID: String, currentUserID: String) -> String?
     - Note: Used to get other user UID
     - parameter conversationID: expects unique ID generated by generateConversationID
     - parameter currentUserID: current Authenticated user UID
     - returns: other user's UID
     */
    
    func getOtherUserID(conversationID: String, currentUserID: String) -> String? {
        let userIDs = conversationID.components(separatedBy: "_")
        
        guard userIDs.count == 2 else {
            return nil
        }
        
        if let otherUserID = userIDs.first(where: { $0 != currentUserID }) {
            return otherUserID
        } else {
            return nil
        }
    }
    
    /**
     func sendMessage(conversationID: String, message: Message, completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> Void)
     - Note: Used to Send Meassages based on unique conversationID
     - parameter conversationID: Expected String, use ChatModel().generateConversationID
     - parameter message: Message format of type struct Message: MessageType {
                                              var sender: SenderType
                                              var messageId: String
                                              var sentDate: Date
                                              var kind: MessageKind
                                              var recipientID: String
                                            }
     - returns: Closure Function returns true if no error else gives error as String
     */
    func sendMessage(conversationID: String, sender: AuthenticatedUser?, message:String?, completionHandler: @escaping (_ error: String?) -> Void) {
        let messageRef = messagesDatabase.child(conversationID).childByAutoId()
        
        let newMessage = [
            "senderId": sender?.uid ?? "",
            "displayName": sender?.displayName ?? "",
            "text": message ?? "",
            "sentDate": Date().timeIntervalSince1970
        ] as [String : Any]
        
        messageRef.setValue(newMessage) { (error, _) in
            if let error = error {
                completionHandler(error.localizedDescription)
            } else {
                completionHandler(nil)
            }
        }
    }
    
    /**
     func observeMessages(conversationID: String, currentUserID: String, otherUserID: String, completionHandler: @escaping ([Message]) -> Void)
     - Note: Used to Fetch Meassages based on unique conversationID
     - parameter conversationID: Expected String, use ChatModel().generateConversationID
     - parameter currentUserID: Authenticated User UID
     - parameter otherUserID: Other User UID
     - returns: returns meassage in format of struct Message: MessageType {
                                         var sender: SenderType
                                         var messageId: String
                                         var sentDate: Date
                                         var kind: MessageKind
                                         var recipientID: String
                                      }
     */
    func observeMessages(conversationID: String, completionHandler: @escaping ([Message]?, _ error: ErrorCode?) -> Void) {
        var messages: [Message] = []
        messagesDatabase.child(conversationID).observe(.childAdded) { snapshot in
            guard let messageData = snapshot.value as? [String: Any] else {
                completionHandler(nil, .noMessage)
                return
            }
            
            // Parse message data
            let senderId = messageData["senderId"] as? String ?? ""
            let displayName = messageData["displayName"] as? String ?? ""
            let text = messageData["text"] as? String ?? ""
            let sentDate = messageData["sentDate"] as? TimeInterval ?? 0
            
            // Create a Message object
            let message = Message(
                sender: Sender(senderId: senderId, displayName: displayName),
                messageId: snapshot.key,
                sentDate: Date(timeIntervalSince1970: sentDate),
                kind: .text(text)
            )
            messages.append(message)
            completionHandler(messages, nil)
        }
    }
    
    func checkConversation(conversationID: String, completionHandler: @escaping (_ isSucceeded: Bool, _ error: ErrorCode?) -> Void) {
        messagesDatabase.child(conversationID).observeSingleEvent(of: .value) { snapshot in
            guard snapshot.exists() else {
                completionHandler(false, .noConversation)
                return
            }
            completionHandler(true, nil)
        }
        
    }

    /**
     Updates the list of connected users for the specified authenticated user.

     This function fetches connected users from the `LoginModel` using the provided `authUserUID`. It processes each user to gather additional details such as conversation information and last message details before invoking the completion handler.

     - Parameters:
       - authUserUID: The authenticated user for whom connected users are being updated.
       - completionHandler: A closure to be called when the update operation completes. It provides an array of user details dictionaries and an optional error message in case of failure.
         - Parameter users: An array of dictionaries containing details of connected users.
         - Parameter error: An optional error message indicating the reason for failure, if any.
     */
    func updateConnectedUser(authUserUID: AuthenticatedUser?, completionHandler: @escaping ([Dictionary<String, Any>]?, String?) -> Void) {
        guard let authUser = authUserUID else {
            completionHandler(nil, "Authenticated user is nil")
            return
        }
        
        LoginModel().fetchConnectedUsers(authUser: authUser) { users, error in
            if let error = error {
                completionHandler(nil, "Failed to fetch connected users: \(error)")
                return
            }
            
            guard let users = users else {
                completionHandler(nil, "No users returned")
                return
            }
            
            self.processUsers(users: users, index: 0, userArray: [], completionHandler: completionHandler)
        }
    }

    /**
     Recursively processes a list of users to gather additional details like conversation and last message information.

     This function iteratively processes each user in the given `users` array, retrieves conversation and message details asynchronously, and constructs user details dictionaries with the gathered information.

     - Parameters:
       - users: An array of dictionaries representing users to be processed.
       - index: The current index of the user being processed.
       - userArray: An array containing dictionaries of user details accumulated during processing.
       - completionHandler: A closure to be called when user processing completes for all users or encounters an error.
         - Parameter userArray: An array of dictionaries containing details of processed users.
         - Parameter error: An optional error message indicating the reason for failure, if any.
     */
    private func processUsers(users: [Dictionary<String, Any>], index: Int, userArray: [[String: Any]], completionHandler: @escaping ([Dictionary<String, Any>]?, String?) -> Void) {
        if index >= users.count {
            completionHandler(userArray, nil)
            return
        }
        
        let user = users[index]
        
        self.checkConversation(conversationID: user["conversationID"] as? String ?? "") { isSucceeded, error in
            if let error = error {
                switch error {
                case .noConversation:
                    let userDetailsDict: [String: Any] = [
                        "displayName": user["displayName"] as? String ?? "",
                        "email": user["email"] as? String ?? "",
                        "photoURL": user["photoURL"] as? String ?? "",
                        "uid": user["uid"] as? String ?? "",
                        "conversationID": user["conversationID"] as? String ?? ""
                    ]
                    var updatedUserArray = userArray
                    updatedUserArray.append(userDetailsDict)
                    
                    self.processUsers(users: users, index: index + 1, userArray: updatedUserArray, completionHandler: completionHandler)
                    
                default:
                    completionHandler(nil, error.description)
                }
            } else if isSucceeded {
                self.observeMessages(conversationID: user["conversationID"] as? String ?? "") { messages, observeError in
                    if let observeError = observeError {
                        completionHandler(nil, "Error observing messages: \(observeError)")
                        return
                    }
                    
                    if let lastMessage = messages?.last {
                        let formatter = DateFormatter()
                        formatter.dateFormat = "h:mm a"
                        let dateString = formatter.string(from: lastMessage.sentDate)
                        
                        let userDetailsDict: [String: Any] = [
                            "displayName": user["displayName"] as? String ?? "",
                            "email": user["email"] as? String ?? "",
                            "photoURL": user["photoURL"] as? String ?? "",
                            "uid": user["uid"] as? String ?? "",
                            "conversationID": user["conversationID"] as? String ?? "",
                            "lastMessage": lastMessage.kind,
                            "lastMessageTime": dateString,
                            "lastMessageSender": lastMessage.sender
                        ]
                        
                        var updatedUserArray = userArray
                        updatedUserArray.append(userDetailsDict)
                        
                        self.processUsers(users: users, index: index + 1, userArray: updatedUserArray, completionHandler: completionHandler)
                    } else {
                        self.processUsers(users: users, index: index + 1, userArray: userArray, completionHandler: completionHandler)
                    }
                }
            }
        }
    }

    // Function to remove a specific message from a conversation
    func removeChildNodeFromConversation(conversationId: String, messageId: String, completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> ()) {
        
        let messageIdRef = messagesDatabase.child(conversationId).child(messageId)
        
        messageIdRef.removeValue { error, _ in
            if let error = error {
                completionHandler(false, error.localizedDescription)
            } else {
                completionHandler(true, nil)
            }
        }
    }
}
