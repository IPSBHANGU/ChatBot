//
//  ChatModel.swift
//  Chatbot
//
//  Created by Umang Kedan on 21/03/24.
//

import FirebaseDatabaseInternal
import FirebaseAuth
import FirebaseStorage
import UIKit
import Kingfisher

struct Message: MessageType {
    var sender: SenderType
    var messageId: String
    var sentDate: Date
    var kind: MessageKind
    var state: Bool
}

struct Sender: SenderType {
    var senderId: String
    var displayName: String
}

public enum MessageKind {
    case text(String)
    case audio(url: URL)
    case photo(imageURL: URL, message:String)
    
    var decode:String {
        switch self {
        case .text(let text):
            return text
        case .audio(_):
            return "Audio Message"
        case .photo(_,_):
            return "Media Message"
        }
    }
    
    var isAudio: Bool {
        if case .audio = self {
            return true
        }
        return false
    }
    
    var isPhoto:Bool {
        if case .photo = self {
            return true
        }
        return false
    }
}

public protocol MessageType {
  var sender: SenderType { get }
  var messageId: String { get }
  var sentDate: Date { get }
  var kind: MessageKind { get }
}

public protocol SenderType {
  var senderId: String { get }
  var displayName: String { get }
}

class ChatModel: NSObject {
    
    let messagesDatabase = Database.database().reference().child("conversation")
    
    /**
     func generateConversationID(user1ID: String, user2ID: String) -> String
     - Note: Used to generate a Unique String which will be used for generating unique chats between users.
     - parameter user1ID: User's (certainly sender)Unique UID generated after Successfull Authentication at firebase
     - parameter user2ID: User's (certainly other user)Unique UID generated after Successfull Authentication at firebase
     - returns: Sorted unique ID in String
     - warning: Do-not modify unless you have a better implementation
     */
    func generateConversationID(user1ID: String, user2ID: String) -> String {
        let sortedUserIDs = [user1ID, user2ID].sorted()
        let conversationID = sortedUserIDs.joined(separator: "_")
        return conversationID
    }
    
    /**
     func getOtherUserID(conversationID: String, currentUserID: String) -> String?
     - Note: Used to get other user UID
     - parameter conversationID: expects unique ID generated by generateConversationID
     - parameter currentUserID: current Authenticated user UID
     - returns: other user's UID
     */
    
    func getOtherUserID(conversationID: String, currentUserID: String) -> String? {
        let userIDs = conversationID.components(separatedBy: "_")
        
        guard userIDs.count == 2 else {
            return nil
        }
        
        if let otherUserID = userIDs.first(where: { $0 != currentUserID }) {
            return otherUserID
        } else {
            return nil
        }
    }
    
    /**
     Sends a message to a specific conversation.

     - Note: This function creates a new message in the specified conversation identified by `conversationID`.

     - Parameters:
       - conversationID: The unique ID of the conversation where the message will be sent.
       - sender: The authenticated user who is sending the message.
       - message: The text content of the message to be sent. Pass `nil` if the message content is empty or if sending a non-text message.
       - completionHandler: A completion handler called after attempting to send the message. If an error occurs during the send operation, the `error` parameter will contain a descriptive error message. If the operation is successful, `error` will be `nil`.

     - Important: This function assumes that `messagesDatabase` is a reference to the Firebase Realtime Database node where messages are stored.

     - Example:
       ```swift
       let conversationID = "unique_conversation_id"
       let currentUser = AuthenticatedUser.current
       let messageText = "Hello, world!"

       ChatModel().sendMessage(conversationID: conversationID, sender: currentUser, message: messageText) { error in
           if let error = error {
               AlerUser().alertUser(viewController: self, title: "Error", message: "Message sending failed: \(error)")
           } else {
               foo().ActionDone
           }
       }
     */
    func sendMessage(conversationID: String, sender: AuthenticatedUser?, message: String?, completionHandler: @escaping (_ error: String?) -> Void) {
        let messageRef = messagesDatabase.child(conversationID).childByAutoId()

        let newMessage: [String: Any] = [
            "senderId": sender?.uid ?? "",
            "displayName": sender?.displayName ?? "",
            "kind": "text", // Represent the message kind as a string
            "message": message ?? "",
            "sentDate": Date().timeIntervalSince1970,
            "state": false
        ]

        messageRef.setValue(newMessage) { (error, _) in
            if let error = error {
                completionHandler(error.localizedDescription)
            } else {
                completionHandler(nil)
            }
        }
    }
    
    /**
     Sends an audio message to a specific conversation.

     - Note: This function sends an audio message to the conversation identified by `conversationID`.

     - Parameters:
       - conversationID: The unique ID of the conversation where the audio message will be sent.
       - sender: The authenticated user who is sending the audio message.
       - audioURL: The URL of the audio file to be sent as a message.
       - duration: The duration of the audio message in seconds.
       - completion: A closure that is called after attempting to send the audio message. If an error occurs during the send operation, the `error` parameter will contain an `ErrorCode` describing the error. If the operation is successful, `error` will be `nil`.

     - Important: This function assumes that `messagesDatabase` is a reference to the Firebase Realtime Database node where messages are stored.

     - Possible Error Codes:
       - `.databaseError`: An error occurred while saving the message data to the database.

     - Example:
       ```swift
       let conversationID = "unique_conversation_id"
       let currentUser = AuthenticatedUser.current
       let audioURL = URL(fileURLWithPath: "path_to_audio_file")
       let duration = 30.0

       sendAudioMessage(conversationID: conversationID, sender: currentUser, audioURL: audioURL, duration: duration) { error in
           if let error = error {
               AlerUser().alertUser(viewController: self, title: "Error", message: "Message sending failed: \(error)")
           } else {
               print("Audio message sent successfully!")
           }
       }
     */

    func sendAudioMessage(conversationID: String, sender: AuthenticatedUser?, audioURL: URL, completion: @escaping (ErrorCode?) -> Void) {
        let messageRef = messagesDatabase.child(conversationID).childByAutoId()
        let storageReference = Storage.storage().reference().child("audioMessages")
        let audioRef = storageReference.child("\(conversationID)_\(Date().timeIntervalSince1970 ).m4a")
            
        // Start the file upload
        audioRef.putFile(from: audioURL, metadata: nil) { metadata, error in
            if let error = error {
                completion(.databaseError)
            } else {
                audioRef.downloadURL { url, error in
                    if let downloadURL = url {
                        let newMessage: [String: Any] = [
                            "senderId": sender?.uid ?? "",
                            "displayName": sender?.displayName ?? "",
                            "kind": "audio", // Represent the message kind as a string
                            "audioURL": downloadURL.absoluteString,
                            "sentDate": Date().timeIntervalSince1970,
                            "state": false
                        ]

                        messageRef.setValue(newMessage) { error, _ in
                            if let error = error {
                                completion(.databaseError)
                            } else {
                                completion(nil)
                            }
                        }
                    } else {
                        completion(.databaseError)
                    }
                }
            }
        }
    }
    
    private func uploadImage(image: UIImage?, conversationID:String, completion: @escaping (Result<URL, Error>) -> Void) {
        guard let imageData = image?.jpegData(compressionQuality: 0.5) else {
            completion(.failure("Error: Unable to convert image to data" as! Error))
            return
        }

        let storageRef = Storage.storage().reference().child("images_messages")
        let imageRef = storageRef.child("\(conversationID)_\(Date().timeIntervalSince1970 ).jpg")

        let metadata = StorageMetadata()
        metadata.contentType = "image/jpeg"

        imageRef.putData(imageData, metadata: metadata) { (metadata, error) in
            if let error = error {
                completion(.failure(error))
            } else {
                imageRef.downloadURL { url, error in
                    if let error = error {
                        completion(.failure(error))
                    }
                    if let url = url {
                        completion(.success(url))
                    }
                }
            }
        }
    }
    
    func sendImageMessage(conversationID: String, sender: AuthenticatedUser?, image: UIImage, message:String?, completion: @escaping (ErrorCode?) -> Void) {
        let messageRef = messagesDatabase.child(conversationID).childByAutoId()
        self.uploadImage(image: image, conversationID: conversationID) { result in
            switch result {
            case .success(let url):
                var newMessage: [String: Any] = [
                    "senderId": sender?.uid ?? "",
                    "displayName": sender?.displayName ?? "",
                    "kind": "photo", // Represent the message kind as a string
                    "imageURL": url.absoluteString,
                    "sentDate": Date().timeIntervalSince1970,
                    "state": false
                ]
                
                if let message = message {
                    newMessage["imageMessage"] = message
                }
                messageRef.setValue(newMessage) { error, _ in
                    if let error = error {
                        completion(.databaseError)
                    } else {
                        completion(nil)
                    }
                }
                
            case .failure(_):
                completion(.databaseError)
            }
        }
    }
    
    /**
     Observes messages in a specific conversation identified by `conversationID`.

     - Note: This function listens for new child nodes (messages) added under the specified conversation in the Firebase Realtime Database.

     - Parameters:
       - conversationID: The unique ID of the conversation to observe.
       - completionHandler: A closure that is called when new messages are observed. The closure takes two parameters:
            - `messages`: An array of `Message` objects representing the observed messages. This array may be empty if no messages are found.
            - `error`: An `ErrorCode` indicating any error that occurred during observation, or `nil` if observation was successful.

     - Important: This function assumes that `messagesDatabase` is a reference to the Firebase Realtime Database node where messages are stored.

     - Possible Error Codes:
       - `.noMessage`: No valid message data was found in the observed snapshot.
       - `.invalidData`: The observed message data contains invalid or unsupported format.

     - Example:
       ```swift
       let conversationID = "unique_conversation_id"

       observeMessages(conversationID: conversationID) { messages, error in
           if let error = error {
               AlerUser().alertUser(viewController: self, title: "Error", message: "Error observing messages: \(error)")
           } else {
               if let messages = messages {
                   for message in messages {
                       print("New message: \(message.sender.displayName): \(message.content)")
                   }
               } else {
                   print("No messages observed.")
               }
           }
       }
    */
    func observeMessages(conversationID: String, completionHandler: @escaping ([Message]?, ErrorCode?) -> Void) {
        var messages: [Message] = []
        messagesDatabase.child(conversationID).observe(.childAdded) { snapshot  in
            guard let messageData = snapshot.value as? [String: Any] else {
                completionHandler(nil, .noMessage)
                return
            }
            
            // Extract message details from snapshot data
            let senderId = messageData["senderId"] as? String ?? ""
            let displayName = messageData["displayName"] as? String ?? ""
            let kindString = messageData["kind"] as? String ?? ""
            let sentDate = messageData["sentDate"] as? TimeInterval ?? 0
            let state = messageData["state"] as? Bool ?? true
            
            // Parse message kind based on the stored type (text or audio)
            var messageKind: MessageKind
            if kindString == "text" {
                let text = messageData["message"] as? String ?? ""
                messageKind = .text(text)
            } else if kindString == "audio" {
                let audioURLString = messageData["audioURL"] as? String ?? ""
                // Convert audioURL back to URL
                if let audioURL = URL(string: audioURLString) {
                    messageKind = .audio(url: audioURL)
                } else {
                    // Handle invalid audioURL
                    completionHandler(nil, .invalidData)
                    return
                }
            } else if kindString == "photo" {
                let imageMessage = messageData["imageMessage"] as? String ?? ""
                let imageURLString = messageData["imageURL"] as? String ?? ""
                // Convert imageURL back to URL
                if let imageURL = URL(string: imageURLString) {
                    messageKind = .photo(imageURL: imageURL, message: imageMessage)
                } else {
                    // Handle invalid imageURL
                    completionHandler(nil, .invalidData)
                    return
                }
            } else {
                // Handle unsupported message kind
                completionHandler(nil, .invalidData)
                return
            }
            
            // Create a Message object
            let message = Message(
                sender: Sender(senderId: senderId, displayName: displayName),
                messageId: snapshot.key,
                sentDate: Date(timeIntervalSince1970: sentDate),
                kind: messageKind,
                state: state
            )
            
            messages.append(message)
            completionHandler(messages, nil)
        }
    }
    
    /**
     Checks the existence of a conversation identified by `conversationID`.

     - Note: This function checks whether a conversation with the specified `conversationID` exists in the Database.

     - Parameters:
       - conversationID: The unique ID of the conversation to check.
       - completionHandler: A closure that is called after checking the conversation existence. The closure takes two parameters:
            - `isSucceeded`: A boolean value indicating whether the conversation exists (`true`) or not (`false`).
            - `error`: An `ErrorCode` describing any error that occurred during the check, or `nil` if the check was successful.

     - Important: This function assumes that `messagesDatabase` is a reference to the Firebase Realtime Database node where conversation data is stored.

     - Possible Error Codes:
       - `.noConversation`: The conversation with the specified `conversationID` does not exist.

     - Example:
       ```swift
       let conversationID = "unique_conversation_id"

       checkConversation(conversationID: conversationID) { exists, error in
           if let error = error {
               print("Error checking conversation: \(error)")
           } else {
               if exists {
                   print("Conversation exists.")
               } else {
                   print("Conversation does not exist.")
               }
           }
       }
     */
    func checkConversation(conversationID: String, completionHandler: @escaping (_ isSucceeded: Bool, _ error: ErrorCode?) -> Void) {
        messagesDatabase.child(conversationID).observeSingleEvent(of: .value) { snapshot in
            guard snapshot.exists() else {
                completionHandler(false, .noConversation)
                return
            }
            completionHandler(true, nil)
        }
        
    }

    /**
     Updates the list of connected users for the specified authenticated user.

     This function fetches connected users from the `LoginModel` using the provided `authUserUID`. It processes each user to gather additional details such as conversation information and last message details before invoking the completion handler.

     - Parameters:
       - authUserUID: The authenticated user for whom connected users are being updated.
       - completionHandler: A closure to be called when the update operation completes. It provides an array of user details dictionaries and an optional error message in case of failure.
         - Parameter users: An array of dictionaries containing details of connected users.
         - Parameter error: An optional error message indicating the reason for failure, if any.
     */
    func updateConnectedUser(authUserUID: AuthenticatedUser?, completionHandler: @escaping ([Dictionary<String, Any>]?, String?) -> Void) {
        guard let authUser = authUserUID else {
            completionHandler(nil, "Authenticated user is nil")
            return
        }
        
        LoginModel().fetchConnectedUsers(authUser: authUser) { users, error in
            if let error = error {
                completionHandler(nil, "Failed to fetch connected users: \(error)")
                return
            }
            
            guard let users = users else {
                completionHandler(nil, "No users returned")
                return
            }
            
            self.processUsers(users: users, index: 0, userArray: [], completionHandler: completionHandler)
        }
    }

    /**
     Recursively processes a list of users to gather additional details like conversation and last message information.

     This function iteratively processes each user in the given `users` array, retrieves conversation and message details asynchronously, and constructs user details dictionaries with the gathered information.

     - Parameters:
       - users: An array of dictionaries representing users to be processed.
       - index: The current index of the user being processed.
       - userArray: An array containing dictionaries of user details accumulated during processing.
       - completionHandler: A closure to be called when user processing completes for all users or encounters an error.
         - Parameter userArray: An array of dictionaries containing details of processed users.
         - Parameter error: An optional error message indicating the reason for failure, if any.
     */
    private func processUsers(users: [Dictionary<String, Any>], index: Int, userArray: [[String: Any]], completionHandler: @escaping ([Dictionary<String, Any>]?, String?) -> Void) {
        if index >= users.count {
            completionHandler(userArray, nil)
            return
        }
        
        let user = users[index]
        
        self.checkConversation(conversationID: user["conversationID"] as? String ?? "") { isSucceeded, error in
            if let error = error {
                switch error {
                case .noConversation:
                    let userDetailsDict: [String: Any] = [
                        "displayName": user["displayName"] as? String ?? "",
                        "email": user["email"] as? String ?? "",
                        "photoURL": user["photoURL"] as? String ?? "",
                        "uid": user["uid"] as? String ?? "",
                        "conversationID": user["conversationID"] as? String ?? ""
                    ]
                    var updatedUserArray = userArray
                    updatedUserArray.append(userDetailsDict)
                    
                    self.processUsers(users: users, index: index + 1, userArray: updatedUserArray, completionHandler: completionHandler)
                    
                default:
                    completionHandler(nil, error.description)
                }
            } else if isSucceeded {
                self.observeMessages(conversationID: user["conversationID"] as? String ?? "") { messages, observeError in
                    if let observeError = observeError {
                        completionHandler(nil, "Error observing messages: \(observeError)")
                        return
                    }
                    
                    if let lastMessage = messages?.last {
                        let formatter = DateFormatter()
                        formatter.dateFormat = "h:mm a"
                        let dateString = formatter.string(from: lastMessage.sentDate)
                        
                        if Auth.auth().currentUser?.uid != lastMessage.sender.senderId {
                            
                            let userDetailsDict: [String: Any] = [
                                "displayName": user["displayName"] as? String ?? "",
                                "email": user["email"] as? String ?? "",
                                "photoURL": user["photoURL"] as? String ?? "",
                                "uid": user["uid"] as? String ?? "",
                                "conversationID": user["conversationID"] as? String ?? "",
                                "state": lastMessage.state,
                                "lastMessage": lastMessage.kind,
                                "lastMessageTime": dateString,
                                "lastMessageSender": lastMessage.sender
                            ]
                            
                            var updatedUserArray = userArray
                            updatedUserArray.append(userDetailsDict)
                            
                            self.processUsers(users: users, index: index + 1, userArray: updatedUserArray, completionHandler: completionHandler)
                        } else {
                            let userDetailsDict: [String: Any] = [
                                "displayName": user["displayName"] as? String ?? "",
                                "email": user["email"] as? String ?? "",
                                "photoURL": user["photoURL"] as? String ?? "",
                                "uid": user["uid"] as? String ?? "",
                                "conversationID": user["conversationID"] as? String ?? "",
                                "lastMessage": lastMessage.kind,
                                "lastMessageTime": dateString,
                                "lastMessageSender": lastMessage.sender
                            ]
                            
                            var updatedUserArray = userArray
                            updatedUserArray.append(userDetailsDict)
                            
                            self.processUsers(users: users, index: index + 1, userArray: updatedUserArray, completionHandler: completionHandler)
                        }
                    } else {
                        self.processUsers(users: users, index: index + 1, userArray: userArray, completionHandler: completionHandler)
                    }
                }
            }
        }
    }
    
    // Function to edit a specific message from a conversation
    func editChildNodeFromConversation(conversationId: String, message: Message, updatedMessageText: String, completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> ()) {
        
        let messageIdRef = messagesDatabase.child(conversationId).child(message.messageId)
        
        messageIdRef.updateChildValues(["text": updatedMessageText]) { error, databaseRef in
            if let error = error {
                completionHandler(false, error.localizedDescription)
            } else {
                completionHandler(true, nil)
            }
        }
    }

    // Function to remove a specific message from a conversation
    func removeChildNodeFromConversation(conversationId: String, messageId: String, completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> ()) {
        
        let messageIdRef = messagesDatabase.child(conversationId).child(messageId)
        
        messageIdRef.removeValue { error, _ in
            if let error = error {
                completionHandler(false, error.localizedDescription)
            } else {
                completionHandler(true, nil)
            }
        }
    }
    
    func markMessagesRead(conversationId: String, messages: [Message], index: Int, completionHandler: @escaping (_ isSucceeded: Bool, _ error: ErrorCode?) -> ()) {
        guard let currentUserUID = Auth.auth().currentUser?.uid else {
            completionHandler(false, .missingUserId)
            return
        }

        guard index < messages.count else {
            // All messages have been processed
            completionHandler(true, nil)
            return
        }

        let message = messages[index]
        let messageId = message.messageId
        let senderId = message.sender.senderId

        // Check if the message sender is not the current user
        if senderId != currentUserUID {
            let messageIdRef = messagesDatabase.child(conversationId).child(messageId)
            messageIdRef.updateChildValues(["state": true]) { error, databaseRef in
                if let error = error {
                    completionHandler(false, .databaseError)
                } else {
                    // Move to the next message
                    self.markMessagesRead(conversationId: conversationId, messages: messages, index: index + 1, completionHandler: completionHandler)
                }
            }
        } else {
            // Skip marking this message as read (not by current user)
            self.markMessagesRead(conversationId: conversationId, messages: messages, index: index + 1, completionHandler: completionHandler)
        }
    }
    
    func discardAudioRecordings(fileURL: URL) -> Result<Bool,Error> {
        do {
            try FileManager.default.removeItem(at: fileURL)
            return .success(true)
        } catch {
            return .failure(error)
        }
    }
}
