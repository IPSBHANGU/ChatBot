//
//  GroupModel.swift
//  Chatbot
//
//  Created by Inderpreet Singh on 24/03/24.
//

import Foundation
import FirebaseDatabaseInternal
import FirebaseAuth
import MessageKit

struct GroupMessage: MessageType {
    var sender: SenderType
    var messageId: String
    var sentDate: Date
    var kind: MessageKind
    var senderAvtar: String
}

class GroupModel: NSObject {
    
    let messagesDatabase = Database.database().reference().child("groupConversation")
    
    /**
     func generateGroupConversationID(userIDs: [String]) -> String
     - Note: Used to generate a Unique String which will be used for generating unique chats between users.
     - parameter userIDs: User's Unique UID String Array generated after Successfull Authentication at firebase
     - returns: Sorted unique ID in String
     - warning: Do-not modify unless you have a better implementation
     */
    func generateGroupConversationID(userIDs: [String]) -> String {
        let sortedUserIDs = userIDs.sorted()
        let conversationID = sortedUserIDs.joined(separator: "_")
        return conversationID
    }
    
    /**
     func getOtherUserIDs(conversationID: String, currentUserID: String) -> [String]?
     - Note: Used to get other user UIDs
     - parameter conversationID: expects unique ID generated by generateGroupConversationID
     - parameter currentUserID: current Authenticated user UID
     - returns: array of other user UIDs
     */
    func getOtherUserIDs(conversationID: String, currentUserID: String) -> [String]? {
        let userIDs = conversationID.components(separatedBy: "_")
        
        guard userIDs.count >= 2 else {
            return nil
        }
        
        let otherUserIDs = userIDs.filter { $0 != currentUserID }
        
        return otherUserIDs.isEmpty ? nil : otherUserIDs
    }

    /**
     func connectUsersInGroupChatInDB(conversationID:String?, groupName:String?,  completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> ())
     - Note: Used to generate groups with users
     - parameter conversationID: expects unique ID in String generated by generateGroupConversationID
     - parameter groupName: expects String format and used for Naming Groups
     - returns: result if error returns a string and false else nil string and true
     */
    func connectUsersInGroupChatInDB(conversationID:String?, groupName:String?,  completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> ()) {
        // Check if groupName is nil or empty
        guard let groupName = groupName, !groupName.isEmpty else {
            completionHandler(false, "Group name cannot be empty")
            return
        }
        
        // Check if conversationID is nil or empty
        guard let conversationID = conversationID, !conversationID.isEmpty else {
            completionHandler(false, "Group conversationID cannot be empty")
            return
        }
        
        let db = Database.database().reference().child("connectedUsersGroup").child(conversationID)
        
        let newConnectedUser = [
            "conversationID": conversationID,
            "groupName": groupName
        ] as [String : Any]
        
        db.setValue(newConnectedUser) { (error, _) in
            if let error = error {
                completionHandler(false, error.localizedDescription)
            } else {
                completionHandler(true, nil)
            }
        }
    }
    
    /**
     func fetchConnectedUsersInGroupChatInDB(userId: String, completion: @escaping ([Dictionary<String, Any>]?, Error?) -> Void)
     - Note: Used to generate groups with users
     - parameter conversationID: expects unique ID in String generated by generateGroupConversationID
     - parameter groupName: expects String format and used for Naming Groups
     - returns: result if error returns a string and false else nil string and true
     */
    func fetchConnectedUsersInGroupChatInDB(userId: String, completion: @escaping ([Dictionary<String, Any>]?, Error?) -> Void) {
        let dbRef = Database.database().reference().child("connectedUsersGroup")
        
        dbRef.observeSingleEvent(of: .value) { snapshot in
            var groups: [Dictionary<String, Any>] = []
            
            for child in snapshot.children {
                if let groupSnapshot = child as? DataSnapshot,
                   let groupData = groupSnapshot.value as? [String: Any],
                   let groupName = groupData["groupName"] as? String,
                   let conversationId = groupData["conversationID"] as? String {
                    
                    // Check if the authenticated user's UID is part of the group
                    if conversationId.contains(userId) {
                        let group: [String: Any] = ["groupName": groupName, "conversationID": conversationId]
                        groups.append(group)
                    }
                }
            }
            
            completion(groups, nil)
        } withCancel: { error in
            completion(nil, error)
        }
    }
    
    /**
     func sendGroupMessage(conversationID: String, message: Message, completionHandler: @escaping (_ isSucceeded: Bool, _ error: String?) -> Void)
     - Note: Used to Send Meassages based on unique conversationID
     - parameter conversationID: Expected String, use ChatModel().generateConversationID
     - parameter sender: Expected User? Object
     - parameter message: Message format of type struct Message: MessageType {
                                              var sender: SenderType
                                              var messageId: String
                                              var sentDate: Date
                                              var kind: MessageKind
                                              var recipientID: String
                                            }
     - returns: Closure Function returns true if no error else gives error as String
     */
    func sendGroupMessage(conversationID: String, sender: User?, message:String?, completionHandler: @escaping (_ error: String?) -> Void) {
        let messageRef = messagesDatabase.child(conversationID).childByAutoId()
        
        let newMessage = [
            "senderId": sender?.uid ?? "",
            "displayName": sender?.displayName ?? "",
            "text": message ?? "",
            "sentDate": Date().timeIntervalSince1970,
            "photoURL": sender?.photoURL?.absoluteString ?? ""
        ] as [String : Any]
        
        messageRef.setValue(newMessage) { (error, _) in
            if let error = error {
                completionHandler(error.localizedDescription)
            } else {
                completionHandler(nil)
            }
        }
    }
    
    /**
     func observeMessages(conversationID: String, currentUserID: String, otherUserID: String, completionHandler: @escaping ([Message]) -> Void)
     - Note: Used to Fetch Meassages based on unique conversationID
     - parameter conversationID: Expected String, use ChatModel().generateConversationID
     - parameter currentUserID: Authenticated User UID
     - returns: returns meassage in format of struct Message: MessageType {
                                         var sender: SenderType
                                         var messageId: String
                                         var sentDate: Date
                                         var kind: MessageKind
                                         var recipientID: String
                                      }
     */
    func observeGroupMessages(conversationID: String, currentUserID: String, completionHandler: @escaping ([GroupMessage]) -> Void) {
        var messages: [GroupMessage] = []
        messagesDatabase.child(conversationID).observe(.childAdded) { snapshot in
            guard let messageData = snapshot.value as? [String: Any] else {
                return
            }
            
            // Parse message data
            let senderId = messageData["senderId"] as? String ?? ""
            let displayName = messageData["displayName"] as? String ?? ""
            let photoURL = messageData["photoURL"] as? String ?? ""
            let text = messageData["text"] as? String ?? ""
            let sentDate = messageData["sentDate"] as? TimeInterval ?? 0
            
            // Create a Message object
            let message = GroupMessage(
                sender: Sender(senderId: senderId, displayName: displayName),
                messageId: snapshot.key,
                sentDate: Date(timeIntervalSince1970: sentDate),
                kind: .text(text),
                senderAvtar: photoURL
            )
            messages.append(message)
            completionHandler(messages)
        }
    }
}
